[{"id":0,"href":"/lds-ctrl-est/docs/","title":"LDS C+E Documentation","section":"LDS Control \u0026 Estimation","content":"LDS Control \u0026amp; Estimation Documentation #  "},{"id":1,"href":"/lds-ctrl-est/docs/tutorials/","title":"LDS C+E Examples","section":"LDS C+E Documentation","content":"Examples #  "},{"id":2,"href":"/lds-ctrl-est/acknowledgements/","title":"Acknowledgements","section":"LDS Control \u0026 Estimation","content":"Acknowledgements #  Development and publication of this library was supported in part by the NIH/NINDS Collaborative Research in Computational Neuroscience (CRCNS)/BRAIN Grant 5R01NS115327-02.\n"},{"id":3,"href":"/lds-ctrl-est/docs/getting-started/getting-started/","title":"Getting Started","section":"LDS C+E Documentation","content":"Getting Started #  This library uses the cross-platform tool CMake to run on Linux, MacOS, and Windows. For general information on the dependencies and configuration, see the instructions for Linux/MacOS. Additional Windows-specific instructions can be found here.\nLinux/MacOS\nWindows\n"},{"id":4,"href":"/lds-ctrl-est/docs/getting-started/linux-macos/","title":"Linux Macos","section":"LDS C+E Documentation","content":"Downloading the Library #  The source code for this library can be downloaded from stanley-rozell/ldsCtrlEst either by downloading a snapshot or cloning the repository via git.\ngit clone https://github.com/stanley-rozell/ldsCtrlEst.git By default, this would check out the master branch. In most cases, we suggest downloading or checking out the latest release instead.\ncd /path/to/ldsCtrlEst git checkout 0.6 Dependencies #  Note that the primary dependencies of this project listed below must be installed along with their header files and with CMake config files or pkg-config files. The latter files are used to configure this project\u0026rsquo;s build. It is strongly encouraged to install the dependencies below using a package manager (e.g., apt, pacman, macports).\n For project configuration, install cmake as well as pkg-config. The latter is optional. The linear algebra library armadillo is used throughout this repository. The HDF5 library is used to save output from example test programs. For use of this library in Matlab executables (mex) on Linux operating systems, you will need OpenBlas, ensuring the static library libopenblas.a is installed. You will also need to install gfortran.  Compilation + Installation #  This project is configured/compiled/installed by way of CMake and (on Unix-based operating systems) GNU Make. For configuration with CMake, there are three available options.\n LDSCTRLEST_BUILD_EXAMPLES : [default= ON] whether to build example programs located under examples/ in the source tree LDSCTRLEST_BUILD_FIT : [default=ON] whether to build the auxiliary fitting portion of the source code that is not pertinent to control implementation LDSCTRLEST_BUILD_STATIC : [default=ON] whether to statically link against OpenBLAS and create a static ldsCtrlEst library for future use  n.b., If both options 2 and 3 are enabled, Matlab/Octave mex functions will be compiled for exposing some of the fitting functionality to Matlab/Octave, assuming these programs are installed.\nBelow are example usages of cmake/make to configure/build the library.\n  For basic project build \u0026amp; install\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake .. #configure build make #build the project sudo make install #[optional] installs to default location (OS-specific)   To set the install prefix\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake -DCMAKE_INSTALL_PREFIX=/your/install/prefix .. #configure build with chosen install location make #build the project make install #install to /your/install/prefix   To build the bare bones project, excluding fit code and Matlab mex code.\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake -DLDSCTRLEST_BUILD_FIT=0 .. #configure not to build the fitting portion of library make #build the project n.b., If you choose not to install the library or install it to the non-default location, ensure you have updated the following environment variables on Unix-based operating systems.\n LD_LIBRARY_PATH: search path for dynamically loaded libraries PKG_CONFIG_PATH: search path for pkg-config tool CMAKE_PREFIX_PATH: search path of prefix where CMake will look for package config files  e.g., Assuming you set -DCMAKE_INSTALL_PREFIX=/your/install/prefix during project configuration and your login shell uses the ~/.profile startup file, open ~/.profile in a text editor and add \u0026hellip;\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/your/install/prefix/lib export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/your/install/prefix/lib/pkgconfig export CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH:/your/install/prefix   Common issues #   \u0026ldquo;I have installed all the dependencies including gfortran with a package manager as suggested; however, cmake complains it cannot find the gfortran library.\u0026rdquo;  When gfortran is installed, its library is usually not installed in a standard location like /usr/lib. gfortran is part of the gcc suite, so their libraries are organized together. e.g., When you install gfortran on Ubuntu using apt, its location is /usr/lib/gcc/x86_64-linux-gnu/9, in the case that gcc version 9 is installed. The build configuration script in ldsCtrlEst is written to add LD_LIBRARY_PATH (Unix) or PATH (Windows) to the CMake library search path on Unix or Windows systems, respectively. Therefore, to fix this issue, simply add the directory in which libgfortran was installed to the OS-appropriate environment variable. Continuing with the Ubuntu example above and assuming a Unix login shell whose startup file is ~/.profile, add the following to the file.\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/gcc/x86_64-linux-gnu/9 \u0026ldquo;I have built the library and installed it in a non-default location. In building my own project linking against ldsCtrlEst, cmake or pkg-config cannot find the library or its configuration information.\u0026rdquo;  If cmake and/or pkg-config cannot find the required configuration files for your project to link against ldsCtrlEst, make sure that these utilities know to look for them in the non-default location where you installed the library. For cmake this means adding your chosen install prefix to the environment variable CMAKE_PREFIX_PATH. Similarly, for pkg-config you need to add your/install/prefix/lib/pkgconfig to its search path, PKG_CONFIG_PATH. Assuming a Unix shell whose login startup file is ~/.profile and ldsCtrlEst was installed using prefix your/install/prefix, add the following to .profile.\nexport CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH:/your/install/prefix export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/your/install/prefix "},{"id":5,"href":"/lds-ctrl-est/docs/getting-started/windows/","title":"Windows","section":"LDS C+E Documentation","content":"Dependencies #  To configure and compile the library, you will need Microsoft Visual Studio. After Visual Studio, install the \u0026ldquo;Desktop Development with C++\u0026rdquo; extension under Tools-\u0026gt;Get Tools and Features, ensuring that the \u0026ldquo;C++ Clang Tools for Windows\u0026rdquo; and \u0026ldquo;CMake C++ Tools for Windows\u0026rdquo; options are checked.\nIn addition to the dependencies mentioned in Linux/MacOS, on Windows, this library opts to use Intel\u0026rsquo;s Math Kernel Library (MKL) for linear algebra, rather than OpenBLAS/gfotran. MKL is part of the OneAPI suite. When using the installation wizard, users may either install the entire base toolkit or just the MKL portion. After installing MKL as well as HDF5, add these libraries to the user\u0026rsquo;s PATH environment variable (System Properties-\u0026gt;Advanced-\u0026gt;Environment Variables). Your installation location may vary, but for example, add the following lines to PATH: C:\\Program Files (x86)\\Intel\\oneAPI\\mkl\\latest\\redist\\intel64, C:\\Program Files\\HDF_Group\\HDF5\\1.12.0\\lib .\nOnce HDF5, MKL, and Visual Studio have been installed, download armadillo as detailed previously for Linux/MacOS. Open the source code in Visual Studio, configure the build (Project -\u0026gt; Generate CMake Cache), and install (Build -\u0026gt; Install). Take note of the install location and add this to an environment variable called CMAKE_PREFIX_PATH; create this variable if it does not already exist.\nCompilation #  After installing the dependencies above and downloading the ldsCtrlEst library source code (see Linux/MacOS), open this directory in Visual Studio. Configure the build (Project -\u0026gt; Generate CMake Cache) and build/install the targets (Build -\u0026gt; Install). Finally, take note of the install location and add this to the environment variable PATH.\nCommon issues #   \u0026ldquo;Generate CMake Cache\u0026rdquo; step errs because creating symbolic links is not permitted.  Certain source files are sym-linked to the build/install directories during configuration with cmake. As such, your user in Windows must be permitted to do so. Make sure that your user is listed next to Control Panel -\u0026gt; Administrative Tools -\u0026gt; Local Policies -\u0026gt; User Rights Assignment -\u0026gt; Create Symbolic Links.\n"},{"id":6,"href":"/lds-ctrl-est/issues-contributing/","title":"Issues Contributing","section":"LDS Control \u0026 Estimation","content":"Reporting Issues #  If you encounter bugs when using this library or have specific feature requests that you believe fall within the stated scope of this project, please open an issue on GitHub and use an appropriate issue template where possible. You may also fork the repository and submit pull-requests with your suggested changes.\nContributing #  We welcome any community contributions to this project. Please fork the repository and if possible use clang-format and clang-tidy to conform to the coding format/style of this repository.\n"},{"id":7,"href":"/lds-ctrl-est/docs/terminology/control-estimation/","title":"C\u0026E","section":"LDS C+E Documentation","content":"Control \u0026amp; Estimation #  The control system provided by this library is comprised of a state estimator and a controller. The estimator is responsible for estimating the latent state of the system, given measurements up to and including the current time (i.e., filtering). At each time step, the controller then uses the resulting state feedback and an internal model of the system to update the inputs to the process being manipulated.\nState estimation #  In general, the filtering performed to estimate the underlying state proceeds recursively by first using the model dynamics to predict the state change at the next time step, followed by updating this prediction when a new measurement is available. For a LDS, this two-step process can be summarized by   \\[\\widehat{\\mathbf{x}}_{t|t-1} = \\mathbf{A}\\widehat{\\mathbf{x}}_{t-1|t-1} \u0026#43; \\mathbf{B} u_{t-1} \u0026#43; \\mathbf{m}_{t-1} \\;,\\]   \\[\\widehat{\\mathbf{x}}_{t|t} = \\widehat{\\mathbf{x}}_{t|t-1} \u0026#43; \\mathbf{K}^{\\rm e}_t \\left(\\mathbf{z}_t - \\widehat{\\mathbf{y}}_{t|t-1}\\right)\\;,\\]  where  \\( \\hat{\\left(\\cdot\\right)}_{t|j} \\)  indicates an estimate at time  \\( t \\)  given data up to time  \\( j \\)  inclusive,  \\( \\mathbf{K}^{\\rm e} \\)  is the estimator gain, and\n \\[ \\widehat{\\mathbf{y}}_{t|t-1} = h\\left( \\widehat{\\mathbf{x}}_{t|t-1} \\right) \\; .\\]  In the case of GLDS models, the estimator gain (called Ke in library) is calculated recursively by Kalman filtering, which requires knowledge of the process noise and measurement noise covariances (Q, R) in addition to the system matrices. For time-invariant GLDS models, the infinite horizon solution is often used, so this gain need not be time-varying. Users may instead set its pre-determined value with the lds::gaussian::System::set_Ke mutator.\nIn the case of PLDS models, there is an analogue of the Kalman filter developed for dynamical systems with point-process observations (Eden et al. 2004). This nonlinear filter recursively updates Ke at each time step and requires an estimate of the process noise covariance (Q) as well.\nAdaptive estimation of process disturbance #  Both the Kalman filter and point-process analogue are model-based; therefore, their performance can be sensitive to model mismatch, whether this be imperfect model fitting or true drifts in system behavior. A practical approach to improving robustness is parameter adaptation. To that end, this library provides dual state-parameter estimation. Specifically, an additive process disturbance (m) is adaptively re-estimated when the lds::System::do_adapt_m property is set to true. This effectively provides integral action on minimizing state estimation error that could either be due to model mismatch or a true disturbance.\nWhen parameter adaptation is enabled, this process disturbance is assumed to vary stochastically on a random walk  \\[\\mathbf{m}_{t} = \\mathbf{m}_{t-1} \u0026#43; \\mathbf{w}^m_{t-1} \\;,\\]  where  \\( \\mathbf{w}^m \\sim \\mathcal{N}\\left(0, \\mathbf{Q}_m\\right)\\)  . Kalman filtering or the point-process analogue are then used to estimate this disturbance in parallel with the state.\nControl #  Given the estimated state, the controller updates the inputs to the system according to the following law:  \\[\\mathbf{u}_{t} = \\mathbf{u}^{\\rm ref}_t - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right)\\;,\\]  where  \\( \\left( \\cdot \\right)^{\\rm ref} \\)  correspond to reference/target signals and  \\( \\mathbf{K}^c_x \\)  is the state feedback controller gain. Recall that these controller gains are assumed to have been designed before the experiment using, for example, LQR.\nIf users are employing integral action for more robust tracking at DC and did not use the approach of augmenting the state vector and system matrices accordingly, there is an option to include the integral term as\n \\[\\mathbf{u}_{t} = \\mathbf{u}^{\\rm ref}_t - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right) - \\mathbf{K}^c_{\\rm inty} \\sum_{j=1}^{t}\\left( \\widehat{\\mathbf{y}}_j - \\mathbf{y}^{\\rm ref}_j \\right) \\;.\\]  An additional option available to users is a control law that updates the change in u,\n \\[\\Delta\\mathbf{u}_{t} = -\\mathbf{K}^c_u \\left(\\mathbf{u}_{t-1} - \\mathbf{u}^{\\rm ref}_{t-1} \\right) - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right)\\;,\\]   \\[\\mathbf{u}_{t} = \\mathbf{u}_{t-1} \u0026#43; \\Delta\\mathbf{u}_{t} \\; .\\]  Notice that this takes the form of a first-order difference equation for updating control (i.e.,  \\( \\Delta\\mathbf{u}_{t} = -\\mathbf{K}^c_u \\mathbf{u}_{t-1} \u0026#43; \\epsilon_{t-1} \\)  ), effectively low-pass filtering the input depending on the characteristics of  \\( \\mathbf{K}^c_u \\)  . This can be useful in cases where users have designed the controller gains by LQR to minimize not the amplitude of the input, but the change in input, by augmenting the state vector with the input during LQR design.\nIntegral action and the  \\( \\Delta \\mathbf{u} \\)  control law can be combined. The library keeps track of the controller type by way of bit masks which can be bit-wise OR\u0026rsquo;d to use in combination.\nCalculating reference state-control from output #  In cases where an output reference is supplied and the goal is to track either a static or slowly varying output, users do not have to produce  \\( \\mathbf{x}^{\\rm ref} \\)  and  \\( \\mathbf{u}^{\\rm ref} \\)  . Methods are provided for calculating the state and control that would be required to reach the reference output at steady state (lds::Controller\u0026lt;System\u0026gt;::ControlOutputReference). This is achieved by linearly-constrained least squares. For single-output systems, it results in an exact solution; however, for multi-output problems it provides a least squares comprimise across outputs.\n"},{"id":8,"href":"/lds-ctrl-est/docs/tutorials/eg_glds_control/","title":"GLDS Control","section":"LDS C+E Examples","content":"GLDS Control Tutorial #  This tutorial shows how to use this library to control a system with a Gaussian LDS controller (lds::gaussian::Controller). In place of a physical system, a GLDS model (lds::gaussian::System) receives control inputs and simulates measurements for the feedback control loop. The controller is assumed to have an imperfect model of the system being controlled (here, a gain mismatch), and there is a stochastic, unmeasured disturbance acting on the system. A combination of integral action and adaptive estimation of this process disturbance is used to perform control.\nThe full code for this can be found here.\nPreamble #  In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; Note that lds::Matrix and lds::Vector are typedefs for arma::Mat\u0026lt;data_t\u0026gt; and arma::Col\u0026lt;data_t\u0026gt;, where the data type is double by default. May be changed to float in include/ldsCtrlEst_h/lds.h if there are memory constraints (e.g., large-scale MIMO control problems).\nCreating a simulated system #  A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 5 seconds.\n// Make 1st-order SISO system, sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt); When a system is initialized, rather than requiring all parameters be provided at construction, users may create a default system by setting only the dimensions and sample period.\n// construct ground truth system to be controlled...  // initializes to random walk model with top-most n_y state observed  lds::gaussian::System controlled_system(n_u, n_x, n_y, dt); This default system is a random walk, where the state matrix is identity, the input matrix is zeros, and the top min(n_x, n_y) states are observed at the output. i.e., for this example,   \\[x_{t\u0026#43;1} = x_t \u0026#43; w_t\\]   \\[y_{t} = x_t\\]  where  \\( w_{t} \\sim \\mathcal{N}\\left( 0, Q \\right) \\)  .\nNow, create non-default parameters for this model.\n// Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); Matrix b_true = Matrix(n_x, n_u).fill(2e-4); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2:  Vector g_true = Vector(n_y).fill(10.0); // output noise covariance  Matrix r_true = Matrix(n_y, n_y, arma::fill::eye) * 1e-4; As mentioned above, this example will feature a stochastic disturbance. More specifically, a process disturbance will randomly change between two values.\n/// Going to simulate a switching disturbance (m) acting on system  size_t which_m = 0; // whether low or high disturbance (0, 1)  data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; // probability of going from low to high disturb.  data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; // initially let m be low  Vector m0_true = Vector(n_y).fill(m_low); Finally, assign the parameters using corresponding set-methods.\n// Assign params.  controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_g(g_true); controlled_system.set_R(r_true); Creating the controller #  Now, create the controller. This requires first constructing the system model that the control uses for estimating state feedback and updating the control signal. A controller is then constructed from this lds::gaussian::System object and upper/lower bounds on the control signal (u_lb, u_ub below), past which the control saturates. Here, the control signal is command voltage sent to an analog driver (e.g., for an LED). Its limits are 0 to 5 V. If your actuator does not saturate somehow, simply set the lower and upper bounds to -lds::kInf and lds::kInf, respectively. Simple saturation is currently the only actuator model in this library.\nFor the sake of this simulation, the system model input matrix is set to an incorrect value. We also assume that the controller feedback gains were designed with an actuator whose conversion factor from volts to physical units (e.g., mW/mm2 optical intensity) differed from the actuator being used in the current experiment.\n// make a controller  lds::gaussian::Controller controller; { // Create **incorrect** model used for control.  // (e.g., imperfect model fitting)  Matrix b_controller = b_true / 2; // let\u0026#39;s assume zero process disturbance initially  // (will be re-estimating)  Vector m_controller = Vector(n_x, arma::fill::zeros); // for this demo, just use arbitrary default R  Matrix r_controller = Matrix(n_y, n_y, arma::fill::eye) * lds::kDefaultR0; lds::gaussian::System controller_system(controlled_system); controller_system.set_B(b_controller); controller_system.set_m(m_controller); controller_system.set_R(r_controller); controller_system.Reset(); // reset to new m  // going to adaptively re-estimate the disturbance  controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise  // acting on random-walk evolution of m  Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-6; controller_system.set_Q_m(q_m); // create controller  // lower and upper bounds on control signal (e.g., in Volts)  data_t u_lb = 0.0; // [=] V  data_t u_ub = 5.0; // [=] V  controller = std::move( lds::gaussian::Controller(std::move(controller_system), u_lb, u_ub)); } Note that the above code block demonstrates how move semantics can be used for assignment/construction. Copy assignment/construction is of course also allowed.\nWith the controller constructed, control variables may be set.\n// Control variables:  // if following enabled, adapts set point with re-estimated process  // disturbance n.b., should not need integral action if this is enabled as the  // adaptive estimator minimizes DC error  bool do_adaptive_set_point = false; // Reference/target output, controller gains  Vector y_ref0 = Vector(n_y).fill(20.0 * dt); Matrix k_x = Matrix(n_u, n_x).fill(100); // gains on state error  Matrix k_inty = Matrix(n_u, n_y).fill(1e3); // gains on integrated err  // setting initial state to target to avoid error at onset:  Vector x0 = Vector(n_x).fill(y_ref0[0]); // set up controller type bit mask so controller knows how to proceed  size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance  control_type = control_type | lds::kControlTypeAdaptM; } else { // use integral action to minimize DC error  control_type = control_type | lds::kControlTypeIntY; } // set controller type  controller.set_control_type(control_type); // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2):  Vector g_design = Vector(n_u).fill(9); // Set params.  // **n.b. using arbitrary defaults for Q, R in this example. Really, these  // should be set by users, as they tune characteristics of Kalman filter.  // Users can also choose not to recursively calculate the estimator gain and  // supply it (setKe) instead of covariances.**  controller.set_y_ref(y_ref0); controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); controller.set_g_design(g_design); Simulating control #  In this demonstration, we will use the ControlOutputReference method which allows users to simply set the reference output and supply the current measurement z. It then calculates the solution for the state/input required to track the reference output at steady state. In this case, the goal is to regulate the output about a constant reference, so it is appropriate here. This method can also be used for time-varying references as long as this variation is slow compared to the dynamics of the system.\nThe control loop is carried out here in a simple for-loop, where a the controlled system is simulated, a measurement taken, and the control signal updated.\n// Simulate the true system.  z.col(t) = controlled_system.Simulate(u_tm1); // This method uses a steady-state solution to control problem to calculate  // x_ref, u_ref from reference output y_ref. Therefore, it is only  // applicable to regulation problems or cases where reference trajectory  // changes slowly compared to system dynamics.  u.col(t) = controller.ControlOutputReference(z.col(t)); Example simulation result #  Below are example results for this simulation, including outputs, latent states, process disturbance, and the control signal. The controller\u0026rsquo;s online estimates of the output, state, and disturbance are given in purple.\n"},{"id":9,"href":"/lds-ctrl-est/docs/terminology/model/","title":"Models","section":"LDS C+E Documentation","content":"Model Definitions #  This library provides methods for control and estimation of linear dynamical systems (LDS) of the following form:   \\[\\mathbf{x}_{t\u0026#43;1} = f\\left( \\mathbf{x}_{t}, \\mathbf{v}_{t} \\right) = \\mathbf{A} \\mathbf{x}_{t} \u0026#43; \\mathbf{B} \\mathbf{v}_{t} \u0026#43; \\mathbf{m}_{t} \u0026#43; \\mathbf{w}_{t}\\]   \\[\\mathbf{y}_{t} = h\\left( \\mathbf{x}_{t} \\right)\\]  t : time index x : system state v = g%u : input (e.g., in physical units used for model fit) u : control signal sent to actuator (e.g., in Volts) y : system output m : process disturbance w ~ N(0, Q) : process noise/disturbance A : state matrix B : input coupling matrix g : input gain (e.g., for converting to control signal actuator voltage) n.b., assumes this conversion is linear Q : process noise covariance % : element-wise multiplication  LDS with Gaussian Observations #  For linear dynamical systems whose outputs are assumed to be corrupted by additive Gaussian noise before measurement (Gaussian LDS models), the output function takes the following form.\n \\[\\mathbf{y}_{t} = \\mathbf{C} \\mathbf{x}_{t} \u0026#43; \\mathbf{d}\\]   \\[\\mathbf{z}_{t} \\sim \\mathcal{N}\\left(\\mathbf{y}_{t} , \\mathbf{R} \\right)\\]  z : measurement C : output matrix d : output bias R : measurement noise covariance  LDS with Poisson Observations #  For linear dynamical systems whose outputs are assumed to be rates underlying measured count data derived from a Poisson distribution (Poisson LDS models), the output function takes the following form. Note an element-wise exponentiation is used to rectify the linear dynamics for the rate of the Poisson process.\n \\[y_{t}^{i} = \\exp \\left(\\mathbf{c}^i \\mathbf{x}_{t} \u0026#43; d^i\\right)\\]   \\[z_{t}^i \\sim \\rm{Poisson} \\left(y_{t}^i \\right)\\]  i : output index z : measurement (count data) c : i^th row of output matrix (C) d : output bias  "},{"id":10,"href":"/lds-ctrl-est/docs/tutorials/eg_plds_state_estimation/","title":"PLDS State Estimation","section":"LDS C+E Examples","content":"PLDS State Estimation Tutorial #  This tutorial shows how to use this library to estimate the state of an LDS with Poisson observations from input/output data. In place of a physical system, another PLDS model (lds::poisson::System) receives random inputs and provides measurements for the state estimator. For the sake of example, the only parameter mismatch is assumed to be the process disturbance, which is adaptively re-estimated.\nThe full code for this can be found here.\nPreamble #  In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; Note that lds::Matrix and lds::Vector are typedefs for arma::Mat\u0026lt;data_t\u0026gt; and arma::Col\u0026lt;data_t\u0026gt;, where the data type is double by default. May be changed to float in include/ldsCtrlEst_h/lds.h if there are memory constraints (e.g., large-scale MIMO control problems).\nCreating a simulated system #  A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 30 seconds.\n// Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; // no. inputs  size_t n_x = 1; // no. states  size_t n_y = 1; // no. outputs  auto n_t = static_cast\u0026lt;size_t\u0026gt;(30 / dt); // no time steps for simulation. When a system is initialized, rather than requiring all parameters be provided at construction, users may create a default system by setting only the dimensions and sample period.\n// construct ground truth system...  lds::poisson::System system_true(n_u, n_x, n_y, dt); This default system is a random walk, where the state matrix is identity, the input matrix is zeros, and the top min(n_x, n_y) states are observed at the output. i.e., for this example,   \\[x_{t\u0026#43;1} = x_t \u0026#43; w_t\\]   \\[y_{t} = \\exp\\left(x_t\\right)\\]  where  \\( w_{t} \\sim \\mathcal{N}\\left( 0, Q \\right) \\)  .\nNow, create non-default parameters for this model.\n// Model parameters  Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.075); Matrix b_true = Matrix(n_x, n_u).fill(1e-2); Vector m0_true = Vector(n_x, arma::fill::zeros).fill(-7e-2); // disturbance  Vector x0_true = m0_true * arma::inv(Matrix(n_x, n_x, arma::fill::eye) - a_true); // initial state Finally, assign the parameters using corresponding set-methods.\n// Assign params.  system_true.set_A(a_true); system_true.set_B(b_true); system_true.set_x0(x0_true); system_true.set_m(m0_true); system_true.Reset(); Creating the estimator #  Now, create the estimator. The system type includes filtering functionality for state estimation, so create another lds::poisson::System. As noted above, the only parameter mismatch in this simulation will be the process disturbance.\n// Construct system for estimation  // e.g., will create a model with incorrect disturbance  lds::poisson::System system_estimator(n_u, n_x, n_y, dt); // Can copy parameters from another system object  system_estimator = system_true; // wrong disturbance  Vector m0_est = m0_true * 2; system_estimator.set_m(m0_est); // set new initial conditions  Vector x0_est = m0_est * arma::inv(Matrix(n_x, n_x, arma::fill::eye) - a_true); // initial state  system_estimator.set_x0(x0_est); system_estimator.Reset(); // reset to initial condition. To ensure robust estimates, adaptively re-estimate the process disturbance.\n// turn on adaptive disturbance estimation  system_estimator.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-6; system_estimator.set_Q_m(q_m); Simulating estimation #  In this demonstration, random inputs are presented to the system, measurements are taken, and filtering is carried out in a for-loop.\n// Simlate the true system.  z.col(t) = system_true.Simulate(u.col(t - 1)); // Filter (predict -\u0026gt; update)  system_estimator.Filter(u.col(t - 1), z.col(t)); Example simulation result #  Below are example results for this simulation, including outputs, latent states, process disturbance, and the input. The online estimates of the output, state, and disturbance are given in purple.\nWith this parameterization, it takes the estimator approximately 5 seconds to minimize state error. The state and output error distributions for the period after 5 seconds is shown below.\n"},{"id":11,"href":"/lds-ctrl-est/docs/tutorials/eg_switched_plds_control/","title":"PLDS Switched Control","section":"LDS C+E Examples","content":"PLDS Switched Control Tutorial #  This tutorial shows how to use this library to control a system with a switched PLDS controller (lds::poisson::SwitchedController). This type of controller is applicable in scenarios where a physical system is not accurately captured by a single LDS but has multiple discrete operating modes where the dynamics can be well-approximated as linear.\nIn the example that follows, another PLDS model (lds::poisson::System) is used in place of a physical system. It receives control inputs and provides measurements for the simulated feedback control loop. This system stochastically flips between two input gains. Here, the controller is assumed to have a perfect model of the switching system being controlled. Note that in practice, users would need to have a decoder that estimates operating mode of the physical system being controlled. This library does not currently include operating mode estimation.\nThe full code for this can be found here.\nPreamble #  In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; Note that lds::Matrix and lds::Vector are typedefs for arma::Mat\u0026lt;data_t\u0026gt; and arma::Col\u0026lt;data_t\u0026gt;, where the data type is double by default. May be changed to float in include/ldsCtrlEst_h/lds.h if there are memory constraints (e.g., large-scale MIMO control problems).\nCreating the simulated system #  A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 30 seconds.\n// whether to do switched control  bool do_switch_ctrl = true; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(30.0 / dt); The system\u0026rsquo;s input matrix (B) will be switched stochastically from one value (b1) to a less sensitive value (b2) according to the following probabilities.\n// for simulating switching  size_t which_mode = 1; data_t pr_21 = 1e-3; // prob mode 1 -\u0026gt; 2  data_t pr_12 = pr_21; // prob mode 2 -\u0026gt; 1 Initially, the system will be in \u0026ldquo;mode\u0026rdquo; 1, where B = b1.\n// simulated system being controlled  lds::poisson::System controlled_system(n_u, n_x, n_y, dt); // **Assume the system is not well characterized by one LDS, but is well  // characterized by two LDS models with different input matrices.**  data_t scale_sys_b = 2; Matrix a(n_x, n_x, arma::fill::eye); a[0] = 0.985; Matrix b1 = Matrix(n_x, n_u).fill(0.05); Vector d = Vector(n_y, arma::fill::zeros).fill(log(1 * dt)); controlled_system.set_A(a); controlled_system.set_B(b1); controlled_system.set_d(d); controlled_system.Reset(); // reset to initial conditions See the GLDS Control and PLDS State Estimation tutorials for more detail about creating System objects.\nCreating the controller #  Now, create the controller. A switched-system controller (SwitchedController) essentially toggles between the parameters of its subsystems when the controller is told a switch has occured. The first thing the user needs to do is define these subsystems. In this example, there are two Poisson systems (sys1, sys2), which are the same save for their input gains.\nSimilar to a non-switched controller, constructing a SwitchedController requires these system models and upper/lower bounds on control. See the GLDS Control tutorial for more details. In the case of a SwitchedController, it needs a list of systems, using the std::vector container.\nMoreover, when assigning control-related signals such as the feedback controller gains, it is crucial that the list of gains optimized for each operating mode of the system have the same dimensionality. For this reason, this library provides UniformMatrixList and UniformVectorList containers that should be used when setting Kc, Kc_inty, g_design. These containers are std::vectors whose contents are uniformly sized.\nPutting this information together, here is how to create the controller and the list of controller gains optimized for each system operating mode.\n// create switched controller  lds::poisson::SwitchedController switched_controller; lds::UniformMatrixList\u0026lt;\u0026gt; k_x; // feedback controller gains  { // create switched controller sub-systems  // system 1  lds::poisson::System sys1(controlled_system); // set process noise covariance  Matrix q_controller = Matrix(n_x, n_x, arma::fill::eye) * 5e-3; sys1.set_Q(q_controller); // adaptively estimate process disturbance (m)  // n.b. using arbitrary default value for process noise if enabled.  sys1.do_adapt_m = true; // setting initial mode to target to avoid large error at onset:  Vector x0_controller = arma::log(y_ref0) - d; sys1.set_x0(x0_controller); sys1.Reset(); // reset to initial conditions  // system 2  lds::poisson::System sys2 = sys1; // set parameters  sys2.set_B(b2); lds::UniformSystemList\u0026lt;lds::poisson::System\u0026gt; systems({sys1, sys2}); // controller gains for underlying systems:  Matrix k_x1(n_u, n_x, arma::fill::ones); Matrix k_x2 = scale_sys_b * k_x1; // system2 is x-times less sensitive.  k_x = lds::UniformMatrixList\u0026lt;\u0026gt;({k_x1, k_x2}); data_t u_lb = 0.0; data_t u_ub = 5.0; switched_controller = std::move( lds::poisson::SwitchedController(std::move(systems), u_lb, u_ub)); } Note that the above code block demonstrates how move semantics can be used for assignment/construction. Copy assignment/construction is of course also allowed.\nNow that the SwitchedController is instantiated, assign its parameters.\n// Control variables  size_t control_type = 0; // no integral action, etc  switched_controller.set_control_type(control_type); switched_controller.set_Kc(std::move(k_x)); switched_controller.set_y_ref(y_ref0); Simulating control #  In this demonstration, we will use the ControlOutputReference method which allows users to simply set the reference output event rate (y_ref) and supply the current measurement z. It then calculates the solution for the state/input required to track that output at steady state. In this case, the goal is to regulate the output about a constant reference, so it is appropriate here. This method can also be used for time-varying references as long as this variation is slow compared to the dynamics of the system. Importantly, this method performs control in the linear state space (i.e., taking the logarithm of the reference output).\nThe control loop is carried out here in a simple for-loop, controlled system is simulated along with stochastic mode switches, a measurement taken, and the control signal updated.\n// Let the controlled system stochastically change gain  // Assume another algorithm decodes this mode change and signals the  // switched_controller  Vector chance(1, arma::fill::randu); if (which_mode == 1) // mode1  { if (chance[0] \u0026lt; pr_21) { which_mode = 2; controlled_system.set_B(b2); if (do_switch_ctrl) { switched_controller.Switch(1); } } } else { // mode2  if (chance[0] \u0026lt; pr_12) { which_mode = 1; controlled_system.set_B(b1); if (do_switch_ctrl) { switched_controller.Switch(0); } } } // Simulate the true system.  z.col(t) = controlled_system.Simulate(u.col(t - 1)); // perform control  u.col(t) = switched_controller.ControlOutputReference(z.col(t)); Note that as the gain of the controlled system changes stochastically, the controller is informed of this change. In practice, a user must decode such changes in the system\u0026rsquo;s operating mode and call the Switch method accordingly. Such a decoder is not currently included in this library.\nExample simulation result #  Below are example results for this simulation, including outputs, latent states, mode switches, and the control signal. The controller\u0026rsquo;s online estimates of the output and state are shown in purple.\nNote that every time the operating mode of the system changes (here, a gain changes), the controller immediately adjusts its inputs. In contrast, a non-switched controller with integral action would also compensate but do so in a comparitively sluggish fashion.\n"}]